<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WGNS / Big G TV Lobby</title>
  <meta name="color-scheme" content="dark" />
  <style>
    :root{ --bg:#000; --fade:900ms; }
    html, body { height:100%; margin:0; background:var(--bg); overflow:hidden; }
    #wrap { position:relative; width:100%; height:100%; background:var(--bg); }
    #playerLayer, #slideshowLayer { position:absolute; inset:0; }
    #slideshowLayer { display:block; background:var(--bg); }
    #playerLayer { display:none; background:var(--bg); }

    #slideshowLayer img{
      position:absolute; inset:0;
      width:100%; height:100%;
      object-fit:cover;
      opacity:0;
      transition: opacity var(--fade) linear;
    }
    #slideshowLayer img.show{ opacity:1; }

    #badge{
      position:absolute; left:18px; bottom:18px;
      padding:8px 10px; border-radius:12px;
      background:rgba(0,0,0,.55);
      color:#fff;
      font:600 14px/1.2 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      letter-spacing:.2px; user-select:none;
      backdrop-filter: blur(6px);
      z-index: 10;
    }
    #badge small{ display:block; opacity:.75; font-weight:500; margin-top:2px; }
    #badge.offline::before{ content:"● "; color:#ff5252; }
    #badge.online::before{ content:"● "; color:#35d07f; }

    #twitch-embed, iframe { width:100% !important; height:100% !important; }
  </style>

  <script src="https://player.twitch.tv/js/embed/v1.js"></script>
</head>
<body>
  <div id="wrap">
    <div id="slideshowLayer"></div>

    <!-- Player starts hidden; we ONLY reveal it after we confirm real playback -->
    <div id="playerLayer">
      <div id="twitch-embed"></div>
    </div>

    <div id="badge" class="offline">OFFLINE<small>Showing lobby loop</small></div>
  </div>

  <script>
    /**
     * Fix for the “old stream title/date + black screen” problem:
     * We NEVER show the Twitch layer unless we confirm actual playback.
     * Twitch can load channel metadata (last title/date) even while offline.
     */

    // ===================== CONFIG =====================
    const CONFIG = {
      channel: "wgnsbiggtv",

      // Put these PNGs in the SAME folder as index.html
      slides: ["WGNS.png","BGTV.png","PTS.png","RWX.png"],
      slideMs: 10000,

      // Check interval for “are we live?”
      pollMs: 20000,

      // How long we give the player to actually start playing before we assume “not live”
      playbackConfirmMs: 6000,

      muted: false,
      volume: 0.5,
      showBadge: true,
    };

    // ===================== DOM =====================
    const slideshowLayer = document.getElementById("slideshowLayer");
    const playerLayer = document.getElementById("playerLayer");
    const badge = document.getElementById("badge");

    function setBadge(state, note){
      if (!CONFIG.showBadge) { badge.style.display = "none"; return; }
      badge.style.display = "block";
      badge.classList.toggle("online", state === "online");
      badge.classList.toggle("offline", state !== "online");
      badge.childNodes[0].nodeValue = (state === "online" ? "LIVE" : "OFFLINE");
      badge.querySelector("small").textContent = note || (state === "online" ? "Playing Twitch stream" : "Showing lobby loop");
    }

    // ===================== SLIDESHOW =====================
    let slideEls = [];
    let slideIdx = 0;
    let slideTimer = null;

    function buildSlides(){
      slideshowLayer.innerHTML = "";
      slideEls = CONFIG.slides.map(src => {
        const img = document.createElement("img");
        img.src = src;
        img.alt = "";
        slideshowLayer.appendChild(img);
        return img;
      });
      slideIdx = 0;
      if (slideEls[0]) slideEls[0].classList.add("show");
    }

    function startSlideshow(){
      if (slideTimer) return;
      if (!slideEls.length) buildSlides();
      slideTimer = setInterval(() => {
        if (!slideEls.length) return;
        slideEls[slideIdx].classList.remove("show");
        slideIdx = (slideIdx + 1) % slideEls.length;
        slideEls[slideIdx].classList.add("show");
      }, CONFIG.slideMs);
    }

    function stopSlideshow(){
      if (slideTimer) clearInterval(slideTimer);
      slideTimer = null;
    }

    // ===================== VIEW TOGGLE =====================
    function showOffline(note){
      // IMPORTANT: Hide Twitch completely so it cannot show “last stream” UI.
      playerLayer.style.display = "none";
      slideshowLayer.style.display = "block";
      startSlideshow();
      setBadge("offline", note || "Showing lobby loop");
      destroyPlayer();
    }

    function showOnline(note){
      slideshowLayer.style.display = "none";
      playerLayer.style.display = "block";
      stopSlideshow();
      setBadge("online", note || "Playing Twitch stream");
    }

    // ===================== LIVE CHECK (CORS-safe page source) =====================
    async function isTwitchLive(channel){
      // GitHub Pages can’t fetch twitch.tv directly (CORS),
      // so we fetch the HTML via a text proxy.
      const url = `https://r.jina.ai/https://www.twitch.tv/${encodeURIComponent(channel)}`;
      try{
        const res = await fetch(url, { cache: "no-store" });
        const text = await res.text();

        // Look for JSON-LD flag in the HTML:
        // "isLiveBroadcast": true / false
        if (text.includes('"isLiveBroadcast":true') || text.includes('"isLiveBroadcast": true')) return true;
        if (text.includes('"isLiveBroadcast":false') || text.includes('"isLiveBroadcast": false')) return false;

        return null; // unknown
      }catch(e){
        return null;
      }
    }

    // ===================== TWITCH PLAYER (hidden until confirmed) =====================
    let player = null;
    let confirming = false;

    function parentDomains(){
      const host = window.location.hostname;
      return host ? [host] : [];
    }

    function createPlayerHidden(){
      document.getElementById("twitch-embed").innerHTML = "";
      player = new Twitch.Player("twitch-embed", {
        channel: CONFIG.channel,
        parent: parentDomains(),
        autoplay: true,
        muted: CONFIG.muted,
      });
      try { player.setVolume(CONFIG.volume); } catch(e) {}
    }

    function destroyPlayer(){
      document.getElementById("twitch-embed").innerHTML = "";
      player = null;
      confirming = false;
    }

    // Confirm real playback by checking that currentTime increases.
    async function confirmPlayback(){
      if (!player) return false;

      // Wait a moment for iframe + playback to initialize
      await sleep(1200);

      let t1 = safeGet(() => player.getCurrentTime?.(), 0);
      await sleep(1200);
      let t2 = safeGet(() => player.getCurrentTime?.(), 0);

      // Some embeds return 0 for a while; try one more time
      await sleep(1200);
      let t3 = safeGet(() => player.getCurrentTime?.(), 0);

      // If time is moving forward, we’re actually playing (not just showing last stream header)
      const moved = (t2 > t1 + 0.2) || (t3 > t2 + 0.2) || (t3 > t1 + 0.5);

      // Also reject obvious “VOD shell” cases if src contains video=
      const iframe = document.querySelector("#twitch-embed iframe");
      const src = iframe?.getAttribute("src") || "";
      const looksVod = src.includes("video=") || src.includes("/videos/");

      return moved && !looksVod;
    }

    function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }
    function safeGet(fn, fallback){
      try{
        const v = fn();
        return (typeof v === "number" && isFinite(v)) ? v : fallback;
      }catch(e){
        return fallback;
      }
    }

    // ===================== STATE MACHINE =====================
    let mode = "offline";

    async function tryGoLive(){
      if (confirming) return;
      confirming = true;

      // Build player, but keep it hidden while we confirm
      createPlayerHidden();
      playerLayer.style.display = "none";

      const ok = await promiseWithTimeout(confirmPlayback(), CONFIG.playbackConfirmMs);

      if (ok === true){
        mode = "online";
        showOnline("Confirmed LIVE");
      } else {
        // If we can’t confirm playback, treat as offline (your exact issue)
        mode = "offline";
        showOffline("Offline (no playback)");
      }

      confirming = false;
    }

    function promiseWithTimeout(promise, ms){
      return Promise.race([
        promise,
        new Promise(resolve => setTimeout(() => resolve(false), ms))
      ]);
    }

    // ===================== INIT =====================
    (function init(){
      buildSlides();
      showOffline("Checking stream status…");

      setInterval(async () => {
        const live = await isTwitchLive(CONFIG.channel);

        if (live === true){
          if (mode !== "online"){
            await tryGoLive();
          }
        } else if (live === false){
          if (mode !== "offline"){
            mode = "offline";
            showOffline("Confirmed OFFLINE");
          } else {
            setBadge("offline", "Confirmed OFFLINE");
          }
        } else {
          // Unknown -> safest is offline slideshow
          if (mode !== "offline"){
            mode = "offline";
            showOffline("Status unknown — showing loop");
          } else {
            setBadge("offline", "Status unknown — showing loop");
          }
        }
      }, CONFIG.pollMs);

      // Press F to toggle fullscreen
      document.addEventListener("keydown", (e) => {
        if (e.key.toLowerCase() === "f") {
          if (!document.fullscreenElement) document.documentElement.requestFullscreen?.();
          else document.exitFullscreen?.();
        }
      });
    })();
  </script>
</body>
</html>
