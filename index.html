<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!-- Reduce caching on GitHub Pages/CDNs during iteration -->
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="0" />
<title>Big G TV Off Air</title>
<style>
  :root { --bg:#000; --fg:#fff; --muted:rgba(255,255,255,.7); }
  html, body { width:100%; height:100%; margin:0; background:var(--bg); color:var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; overflow:hidden; }
  /* Fullscreen stage */
  #stage { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; }
  /* Blurred animated background */
  #blur-bg{
    position:absolute; inset:-40px;
    background:
      radial-gradient(1200px 600px at 20% 20%, rgba(59,130,246,.35), transparent 60%),
      radial-gradient(1200px 600px at 80% 80%, rgba(16,185,129,.28), transparent 60%),
      radial-gradient(1200px 600px at 80% 15%, rgba(239,68,68,.22), transparent 60%);
    filter: blur(28px);
    transform: scale(1.1);
    animation: drift 16s ease-in-out infinite alternate;
    opacity:.9;
  }
  @keyframes drift{
    from { transform: scale(1.1) translate3d(-18px, -10px, 0); }
    to   { transform: scale(1.15) translate3d(18px, 12px, 0); }
  }
  #scrim { position:absolute; inset:0; background:rgba(0,0,0,.55); }

  /* Content layer */
  #content { position:relative; width:100%; height:100%; display:flex; flex-direction:column; }

  /* Header */
  #header{ padding:28px 36px 0 36px; display:flex; gap:18px; align-items:baseline; justify-content:space-between; }
  #wg-title{ font-size:38px; font-weight:800; letter-spacing:-0.02em; margin:0; }
  #wg-sub{ font-size:16px; color:var(--muted); margin-top:6px; }

  /* Body */
  #body{ flex:1; min-height:0; display:flex; align-items:center; justify-content:center; padding:18px 36px 36px 36px; }
  #media-wrap{
    position:relative;
    width:min(92vw, 1560px);
    height:min(62vh, 820px);
    border-radius:22px;
    overflow:hidden;
    box-shadow: 0 18px 60px rgba(0,0,0,.55);
    background:rgba(0,0,0,.35);
  }

  /* Slideshow image */
  #slide{
    position:absolute; inset:0;
    width:100%; height:100%;
    object-fit:contain;
    background:rgba(0,0,0,.25);
    opacity:1;
    transition: opacity .6s ease;
  }

  /* YouTube */
  #yt-embed{
    position:absolute; inset:0;
    width:100%; height:100%;
    border:0;
    display:none; /* offair default */
    background:#000;
  }

  /* Status pill */
  #status{
    position:absolute; left:18px; top:18px;
    padding:8px 12px;
    border-radius:999px;
    background:rgba(0,0,0,.55);
    border:1px solid rgba(255,255,255,.14);
    font-size:12px;
    color:rgba(255,255,255,.85);
    backdrop-filter: blur(10px);
  }

  /* Debug box */
  #debug{
    position:fixed; left:16px; bottom:16px;
    width:min(720px, calc(100vw - 32px));
    max-height:40vh;
    overflow:auto;
    white-space:pre-wrap;
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    font-size:12px;
    line-height:1.35;
    padding:10px 12px;
    border-radius:12px;
    background:rgba(0,0,0,.75);
    border:1px solid rgba(255,255,255,.14);
    display:none;
  }
</style>
</head>
<body>
<div id="stage">
  <div id="blur-bg"></div>
  <div id="scrim"></div>

  <div id="content">
    <div id="header">
      <div>
        <h1 id="wg-title">Big G TV is Off Air (for now)</h1>
        <div id="wg-sub">Weâ€™ll switch to LIVE automatically when we go live.</div>
      </div>
    </div>

    <div id="body">
      <div id="media-wrap">
        <div id="status">OFF AIR</div>
        <img id="slide" alt="Off Air Slide" />
        <iframe id="yt-embed" allow="autoplay; encrypted-media; picture-in-picture" allowfullscreen></iframe>
      </div>
    </div>
  </div>
</div>

<div id="debug"></div>

<script>
(() => {
  const BUILD = 'v27.0';
  const BUILD_TS = '2026-01-06';
  // ======== CONFIG ========
  const CONFIG = {
    // Your channel ID:
    channelId: 'UCaR9jZW5TJNrSg7w70czrsw',

    // Slideshow
    slides: ['WGNS.png','BGTV.png','PTS.png','RWX.png'],
    slideMs: 6000,

    // Live probing (no API key): parse the channel /live page through a text proxy
    liveProbeMs: 6000,
    liveProbeTimeoutMs: 7000,
    // IMPORTANT: keep this HTTPS
    liveProxyPrefix: 'https://r.jina.ai/https://www.youtube.com/channel/',
    liveProxyHandlePrefix: 'https://r.jina.ai/https://www.youtube.com/@',
    handle: 'newsradiowgns',

    // YouTube embed tuning
    embedParams: 'autoplay=1&mute=1&playsinline=1&rel=0&modestbranding=1'
  };

  // ======== DEBUG ========
  const debugEl = document.getElementById('debug');
  const debugEnabled = (new URLSearchParams(location.search).get('debug') === '1') || (location.hash.includes('debug'));
  function showDebug(){ debugEl.style.display = 'block'; }
  function log(msg){
    if (!debugEnabled) return;
    showDebug();
    const ts = new Date().toLocaleTimeString();
    debugEl.textContent += `[${ts}] ${msg}\n`;
    debugEl.scrollTop = debugEl.scrollHeight;
  }

  // If debug is enabled, announce build so we can confirm which version is deployed.
  log(`boot ${BUILD} (${BUILD_TS})`);

  // Always show build/version in debug so we can confirm deploy.
  log(`boot ok (${BUILD} ${BUILD_TS})`);
  // If anything errors, show it.
  window.addEventListener('error', (e) => {
    showDebug();
    debugEl.textContent += `\n[ERROR] ${e.message}\n`;
  });
  window.addEventListener('unhandledrejection', (e) => {
    showDebug();
    debugEl.textContent += `\n[REJECT] ${String(e.reason)}\n`;
  });

  // ======== ELEMENTS ========
  const statusEl = document.getElementById('status');
  const slideEl = document.getElementById('slide');
  const ytEl = document.getElementById('yt-embed');

  // ======== SLIDESHOW ========
  let slideIdx = 0;
  function setSlide(i){
    const src = CONFIG.slides[i] + '?v=' + Date.now();
    slideEl.style.opacity = '0';
    // load -> fade in
    const img = new Image();
    img.onload = () => {
      slideEl.src = src;
      requestAnimationFrame(() => slideEl.style.opacity = '1');
      log('slide OK ' + src);
    };
    img.onerror = () => {
      log('slide FAIL ' + src + ' (check file name + folder)');
      // Keep old slide; also show a black fallback
      slideEl.style.opacity = '1';
    };
    img.src = src;
  }
  function startSlideshow(){
    setSlide(slideIdx);
    setInterval(() => {
      if (mode !== 'offair') return;
      slideIdx = (slideIdx + 1) % CONFIG.slides.length;
      setSlide(slideIdx);
    }, CONFIG.slideMs);
  }

  // ======== LIVE DETECTION ========
  let mode = 'offair';
  let lastVideoId = '';
  function setMode(next){
    if (mode === next) return;
    mode = next;
    if (mode === 'live'){
      statusEl.textContent = 'LIVE';
      slideEl.style.display = 'none';
      ytEl.style.display = 'block';
      log('MODE -> LIVE');
    } else {
      statusEl.textContent = 'OFF AIR';
      ytEl.style.display = 'none';
      slideEl.style.display = 'block';
      log('MODE -> OFF AIR');
    }
  }

  function embedUrlForVideoId(vid){
    return `https://www.youtube.com/embed/${vid}?${CONFIG.embedParams}`;
  }
  function embedUrlForChannelLive(){
    // Fallback that sometimes goes stale; we still keep it as a backup.
    return `https://www.youtube.com/embed/live_stream?channel=${CONFIG.channelId}&${CONFIG.embedParams}`;
  }

  async function fetchText(url, timeoutMs){
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try{
      const res = await fetch(url, { signal: ctrl.signal, cache:'no-store' });
      const txt = await res.text();
      return { ok: res.ok, status: res.status, text: txt };
    } finally {
      clearTimeout(t);
    }
  }

  function extractLiveVideoId(htmlText){
    // The YouTube /live page HTML can vary a lot, and some proxies strip big script blobs.
    // Strategy:
    //  1) Prefer explicit embed/watch URLs from OG/meta tags (these usually point at the primary content).
    //  2) If we can detect "live" signals, only then trust broader patterns.
    //  3) Never pick random watch?v IDs from recommendations.

    const liveSignals = (
      htmlText.includes('"isLiveNow":true') ||
      htmlText.includes('"isLiveContent":true') ||
      htmlText.includes('LIVE_NOW') ||
      htmlText.includes('liveStreamability') ||
      htmlText.includes('isLiveBroadcast') ||
      htmlText.includes('"liveBroadcastDetails"')
    );

    // 1) Strong: og:video / embedUrl (often present even when scripts are stripped)
    let m = htmlText.match(/<meta\s+property="og:video:url"\s+content="https:\/\/www\.youtube\.com\/embed\/([a-zA-Z0-9_-]{11})"/);
    if (m && liveSignals) return m[1];

    m = htmlText.match(/<meta\s+property="og:video:secure_url"\s+content="https:\/\/www\.youtube\.com\/embed\/([a-zA-Z0-9_-]{11})"/);
    if (m && liveSignals) return m[1];

    m = htmlText.match(/itemprop="embedUrl"\s+content="https:\/\/www\.youtube\.com\/embed\/([a-zA-Z0-9_-]{11})"/);
    if (m && liveSignals) return m[1];

    return '';
  }

  async function confirmLiveVideoId(vid){
    // Confirm by checking the watch page for live signals (more stable than player state).
    const watchUrl = `https://r.jina.ai/https://www.youtube.com/watch?v=${vid}`;
    const res = await fetchText(watchUrl, CONFIG.liveProbeTimeoutMs);
    log(`confirm ${res.status} ${watchUrl}`);
    if (!res.ok) return false;
    const t = res.text;
    return (
      t.includes('"isLiveNow":true') ||
      t.includes('"isLiveContent":true') ||
      t.includes('LIVE_NOW') ||
      t.includes('liveStreamability') ||
      t.includes('isLiveBroadcast') ||
      t.includes('"liveBroadcastDetails"')
    );
  }

  async function probeViaOEmbed(url){
    // Ask YouTube oEmbed what video the /live URL resolves to, then confirm it's live.
    const oembed = `https://www.youtube.com/oembed?url=${encodeURIComponent(url)}&format=json`;
    const res = await fetchText(oembed, CONFIG.liveProbeTimeoutMs);
    log(`oembed ${res.status} ${oembed}`);
    if (!res.ok) return '';
    try{
      const j = JSON.parse(res.text);
      const html = j && j.html ? String(j.html) : '';
      const m = html.match(/youtube\.com\/embed\/([a-zA-Z0-9_-]{11})/);
      if (m && m[1]){
        const vid = m[1];
        if (await confirmLiveVideoId(vid)) return vid;
      }
    }catch(e){
      log(`oembed parse err: ${e && e.message ? e.message : e}`);
    }
    return '';
  }

  async function probeLive(){
    const channelLiveUrl = `https://www.youtube.com/channel/${CONFIG.channelId}/live`;
    const handleLiveUrl = CONFIG.handle ? `https://www.youtube.com/@${CONFIG.handle}/live` : '';

    // 1) oEmbed resolution + confirm (most reliable when /live HTML is stripped)
    let vid = await probeViaOEmbed(channelLiveUrl);
    if (vid) return vid;
    if (handleLiveUrl){
      vid = await probeViaOEmbed(handleLiveUrl);
      if (vid) return vid;
    }

    return '';
  }

  
  // ======== LIVE DETECTION (v27) ========
  // Why: YouTube oEmbed returns 404 for /live URLs, and the normal channel-live embed can "stick" until refresh.
  // Approach: Poll the channel/handle /live page through r.jina.ai at a LOW rate + backoff, extract the primary og:url videoId,
  // then swap the iframe to /embed/<videoId>.
  let probing = false;
  let backoffMs = 25000;
  const BACKOFF_MIN = 25000;
  const BACKOFF_MAX = 5 * 60 * 1000;

  function nextBackoff(success){
    if (success){
      backoffMs = BACKOFF_MIN;
    } else {
      backoffMs = Math.min(BACKOFF_MAX, Math.floor(backoffMs * 1.6));
    }
  }

  function extractLiveVideoIdFromHtml(html){
    const s = String(html);

    // 1) Canonical/og:url is the most reliable when the /live endpoint is actively pointing at a live watch page
    // Example: <meta property="og:url" content="https://www.youtube.com/watch?v=VIDEOID">
    let m = s.match(/property=["']og:url["'][^>]*content=["']https:\/\/www\.youtube\.com\/watch\?v=([A-Za-z0-9_-]{11})["']/i);
    if (m && m[1]) return m[1];

    m = s.match(/rel=["']canonical["'][^>]*href=["']https:\/\/www\.youtube\.com\/watch\?v=([A-Za-z0-9_-]{11})["']/i);
    if (m && m[1]) return m[1];

    // 2) JSON blobs sometimes include canonicalBaseUrl when live
    m = s.match(/"canonicalBaseUrl"\s*:\s*"\/watch\?v=([A-Za-z0-9_-]{11})"/);
    if (m && m[1]) return m[1];

    // 3) As a fallback, only accept a videoId if we see strong live indicators nearby
    const liveSignal = /"isLiveNow"\s*:\s*true|"isLiveContent"\s*:\s*true|LIVE_NOW|liveStreamability|isLiveBroadcast/i.test(s);
    if (liveSignal){
      m = s.match(/"videoId"\s*:\s*"([A-Za-z0-9_-]{11})"/);
      if (m && m[1]) return m[1];
    }
    return null;
  }

  async function fetchJina(url){
    const target = 'https://r.jina.ai/https://www.youtube.com' + url;
    const res = await fetch(target, { cache: 'no-store' });
    const text = await res.text();
    return { ok: res.ok, status: res.status, url: target, text };
  }

  async function liveLoop(){
    if (probing) return;
    probing = true;

    try{
      // Try both channel and handle /live routes; whichever yields a real og:url watch page wins.
      const candidates = [
        '/channel/' + CONFIG.channelId + '/live',
        '/@' + CONFIG.handle + '/live'
      ];

      let found = null;

      for (const path of candidates){
        let res;
        try{
          res = await fetchJina(path);
          log(`probe ${res.status} ${res.url}`);
        } catch (e){
          log(`probe error (${path}) ${e && e.name ? e.name : e}`);
          continue;
        }

        // Handle rate limits gracefully
        if (res.status === 429){
          // Do not spam; backoff
          continue;
        }
        if (!res.ok){
          continue;
        }

        const vid = extractLiveVideoIdFromHtml(res.text);
        if (vid){
          found = vid;
          break;
        }
      }

      if (found){
        if (CONFIG.currentMode !== 'LIVE' || CONFIG.currentVideoId !== found){
          log(`SWITCH iframe -> videoId ${found}`);
          CONFIG.currentVideoId = found;
          CONFIG.currentMode = 'LIVE';
          setModeUI('LIVE');

          // Swap iframe to the specific video (more reliable than live_stream?channel=...)
          ytEl.src = embedUrlForVideoId(found);
        }
        nextBackoff(true);
      } else {
        // No live detected
        if (CONFIG.currentMode !== 'OFFAIR'){
          CONFIG.currentMode = 'OFFAIR';
          CONFIG.currentVideoId = null;
          setModeUI('OFFAIR');
          ytEl.src = offairEmbedUrl();
          log('MODE -> OFFAIR');
        }
        nextBackoff(false);
      }
    } finally {
      probing = false;
      setTimeout(liveLoop, backoffMs);
    }
  }


  // ======== BOOT ========
  log('boot ok');
  startSlideshow();
  liveLoop();
})();
</script>
</body>
</html>
